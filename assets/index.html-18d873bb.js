import{_ as t,X as d,Y as o,a1 as r}from"./framework-9435e890.js";const e={},a=r('<table><thead><tr><th>调度策略</th><th>static</th><th>dynamic</th><th>guided</th></tr></thead><tbody><tr><td>Sort uniform parts</td><td>70.4433 ms</td><td>94.0649 ms</td><td>69.919 ms</td></tr><tr><td>Sort random parts</td><td>1436.51 ms</td><td>1376.06 ms</td><td>1443.13 ms</td></tr></tbody></table><h2 id="sort-uniform-parts" tabindex="-1"><a class="header-anchor" href="#sort-uniform-parts" aria-hidden="true">#</a> Sort Uniform Parts</h2><p>由于每个 part 的长度相同, 每次迭代的开销基本均衡. <code>nUniformParts = 100000</code>, 总迭代次数较 <strong>多</strong>.</p><p>因此, 分配过程耗时较长的 <code>dynamic</code> 调度开销显著高于 <code>static</code> 和 <code>guided</code>.</p><p>考虑到每次迭代的开销波动, 使用 <code>static</code> 调度的负载并不完全均衡. 而使用 <code>guided</code> 调度能够通过 <strong>引入较小的开销优化由于波动产生的负载不均</strong>.</p><h2 id="sort-random-parts" tabindex="-1"><a class="header-anchor" href="#sort-random-parts" aria-hidden="true">#</a> Sort Random Parts</h2><p>每个 part 的长度较为不均, 每次迭代的开销极不均衡. <code>nRandomParts = 100</code>, 总迭代次数较 <strong>少</strong>.</p><p>因此, 使用 <code>static</code> 和 <code>guided</code> 将导致负载的极不均衡. 而 <code>dynamic</code> 虽然引入了分配开销, 但总迭代次数少, <strong>负载均衡带来的收益</strong> 能够弥补 <strong>分配</strong> 带来的额外开销.</p>',8),s=[a];function c(n,i){return d(),o("div",null,s)}const m=t(e,[["render",c],["__file","index.html.vue"]]);export{m as default};
