const e=JSON.parse('{"key":"v-1cf25e0e","path":"/course-work/csapp/2022/06/06/malloc-lab/","title":"Malloc Lab","lang":"en-US","frontmatter":{"lastUpdated":true,"contributors":true,"editLink":true,"category":["Course Work"],"tag":["Computer Organization and Architecture","Malloc Lab"],"isOriginal":true,"date":"2022-06-06T00:00:00.000Z","permalinkPattern":"course-work/csapp/:year/:month/:day/:slug","title":"Malloc Lab","description":"基于 Segregated Free Lists + First Fit + Immediate Coalescing + Smart Reallocation 实现. Segregated Free Lists 使用最开始的 9 个 Word 存储 (0, 32], (32, 64], …, (2048, 4096], (4096, inf) 分块大小的 Free List Head, 同时维护这 9 个链表. 在代码中, 我们约定 Pred 和 Succ 表示链表中的拓扑顺序, Prev 和 Next 表示 block 在 mem_heap 上的地址顺序.","head":[["meta",{"property":"og:url","content":"https://blog.liblaf.me/course-work/csapp/2022/06/06/malloc-lab/"}],["meta",{"property":"og:site_name","content":"Blog"}],["meta",{"property":"og:title","content":"Malloc Lab"}],["meta",{"property":"og:description","content":"基于 Segregated Free Lists + First Fit + Immediate Coalescing + Smart Reallocation 实现. Segregated Free Lists 使用最开始的 9 个 Word 存储 (0, 32], (32, 64], …, (2048, 4096], (4096, inf) 分块大小的 Free List Head, 同时维护这 9 个链表. 在代码中, 我们约定 Pred 和 Succ 表示链表中的拓扑顺序, Prev 和 Next 表示 block 在 mem_heap 上的地址顺序."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-02-24T05:36:48.000Z"}],["meta",{"property":"article:tag","content":"Computer Organization and Architecture"}],["meta",{"property":"article:tag","content":"Malloc Lab"}],["meta",{"property":"article:published_time","content":"2022-06-06T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-24T05:36:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Malloc Lab\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-06-06T00:00:00.000Z\\",\\"dateModified\\":\\"2023-02-24T05:36:48.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Segregated Free Lists","slug":"segregated-free-lists","link":"#segregated-free-lists","children":[]},{"level":2,"title":"First Fit","slug":"first-fit","link":"#first-fit","children":[]},{"level":2,"title":"Immediate Coalescing","slug":"immediate-coalescing","link":"#immediate-coalescing","children":[]},{"level":2,"title":"Smart Reallocation","slug":"smart-reallocation","link":"#smart-reallocation","children":[]},{"level":2,"title":"mm_check()","slug":"mm-check","link":"#mm-check","children":[]},{"level":2,"title":"Performance","slug":"performance","link":"#performance","children":[{"level":3,"title":"Segregated Free Lists + First Fit + Immediate Coalescing + Smart Reallocation","slug":"segregated-free-lists-first-fit-immediate-coalescing-smart-reallocation","link":"#segregated-free-lists-first-fit-immediate-coalescing-smart-reallocation","children":[]},{"level":3,"title":"Implicit Free Lists + First Fit + Immediate Coalescing + Naive Reallocation","slug":"implicit-free-lists-first-fit-immediate-coalescing-naive-reallocation","link":"#implicit-free-lists-first-fit-immediate-coalescing-naive-reallocation","children":[]},{"level":3,"title":"Implicit Free Lists + Next Fit + Immediate Coalescing + Naive Reallocation","slug":"implicit-free-lists-next-fit-immediate-coalescing-naive-reallocation","link":"#implicit-free-lists-next-fit-immediate-coalescing-naive-reallocation","children":[]},{"level":3,"title":"Implicit Free Lists + Best Fit + Immediate Coalescing + Naive Reallocation","slug":"implicit-free-lists-best-fit-immediate-coalescing-naive-reallocation","link":"#implicit-free-lists-best-fit-immediate-coalescing-naive-reallocation","children":[]}]}],"git":{"createdTime":1677217008000,"updatedTime":1677217008000,"contributors":[{"name":"Qin Li","email":"liblaf@outlook.com","commits":1}]},"readingTime":{"minutes":2.74,"words":822},"filePathRelative":"course-work/csapp/2022-06-06-malloc-lab.md","localizedDate":"June 6, 2022","excerpt":"<p>基于 Segregated Free Lists + First Fit + Immediate Coalescing + Smart Reallocation 实现.</p>\\n<h2> Segregated Free Lists</h2>\\n<p>使用最开始的 9 个 Word 存储 (0, 32], (32, 64], …, (2048, 4096], (4096, inf) 分块大小的 Free List Head, 同时维护这 9 个链表.</p>\\n<p>在代码中, 我们约定 <code>Pred</code> 和 <code>Succ</code> 表示链表中的拓扑顺序, <code>Prev</code> 和 <code>Next</code> 表示 block 在 <code>mem_heap</code> 上的地址顺序.</p>","autoDesc":true}');export{e as data};
