import{_ as e,X as a,Y as o,a1 as c}from"./framework-9435e890.js";const d={},r=c('<h2 id="performance" tabindex="-1"><a class="header-anchor" href="#performance" aria-hidden="true">#</a> Performance</h2><figure><img src="https://res.cloudinary.com/liblaf/image/upload/v1677215251/2023/02/24/20230224-1677215249.png" alt="naive" tabindex="0" loading="lazy"><figcaption>naive</figcaption></figure><figure><img src="https://res.cloudinary.com/liblaf/image/upload/v1677215269/2023/02/24/20230224-1677215267.png" alt="shared_memory" tabindex="0" loading="lazy"><figcaption>shared_memory</figcaption></figure><figure><img src="https://res.cloudinary.com/liblaf/image/upload/v1677215289/2023/02/24/20230224-1677215286.png" alt="compare-x" tabindex="0" loading="lazy"><figcaption>compare-x</figcaption></figure><figure><img src="https://res.cloudinary.com/liblaf/image/upload/v1677215306/2023/02/24/20230224-1677215303.png" alt="compare-y" tabindex="0" loading="lazy"><figcaption>compare-y</figcaption></figure><h2 id="analysis" tabindex="-1"><a class="header-anchor" href="#analysis" aria-hidden="true">#</a> Analysis</h2><p>当 <code>block_size = 32 * 1</code> 时, <code>block_size</code> 过小, <code>grid</code> 数量过多, 导致调度产生的开销过大, 因此耗时较长.</p><p>在一些 <code>block_size</code> 取值处, 例如 <code>block_size = 32 * 16, 32 * 21</code> 等, <code>naive</code> 和 <code>shared_memory</code> 的性能都出现了较大幅度的跳变, 暂时想不出来为什么.</p><p>Shared Memory 带来的提升, 主要是通过增加内存访问时间以及 <code>__syncthreads</code> 开销, 以减少对同一元素重复调用 <code>calc</code> 方法. 当 <code>block_size</code> 较小时, <code>__syncthreads</code> 的开销较小, 因此 Shared Memory 能够带来一定的提升. 但随着 <code>block_size</code> 的增大, 同步的开销逐步增加, 导致 Shared Memory 带来的提升不明显, 甚至产生了负面影响.</p><p>事实上, 使用 Shared Memory 的实现对于每个 Thread 而言负载极不均衡. 位于边界的 Thread 需要进行数次 <code>calc</code>, 而位于 Block 内部的 Thread 只需要进行一次计算. 负载分配策略仍有优化空间. 除此之外, Shared Memory 实现使用了多次 <code>if</code>, 这也可能带来性能的损耗.</p><p>不难看出, Shared Memory 往往伴随着线程同步一起使用. 对于 CPU Bound 类型的程序, 通过划分较小的 <code>block_size</code>, 并使用 Shared Memory 优化, 应该能够有效提升程序性能. 而对于 Memory Bound 类型的程序, 使用 Shared Memory 减少重复计算显然得不偿失. 这时, Shared Memory 可能并不能带来性能的提升, 反而因为 Shared Memory 的访问速度限制使得程序性能更加糟糕.</p>',11),i=[r];function n(l,s){return a(),o("div",null,i)}const m=e(d,[["render",n],["__file","index.html.vue"]]);export{m as default};
